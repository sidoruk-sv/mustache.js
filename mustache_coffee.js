// Generated by CoffeeScript 1.8.0

/*
 mustache.js - Logic-less {{mustache}} templates with JavaScript
 http://github.com/janl/mustache.js
 */

(function() {
  var factory,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  factory = function(mustache) {
    var Context, Object_toString, RegExp_test, Scanner, Writer, curlyRe, defaultWriter, entityMap, equalsRe, escapeHtml, escapeRegExp, isArray, isArrayOld, isFunction, isWhitespace, nestTokens, nonSpaceRe, parseTemplate, spaceRe, squashTokens, tagRe, testRegExp, whiteRe;
    Object_toString = Object.prototype.toString;
    isArrayOld = function(object) {
      return Object_toString.call(object) === '[object Array]';
    };
    isArray = Array.isArray || isArrayOld;
    isFunction = function(object) {
      return typeof object === 'function';
    };
    escapeRegExp = function(string) {
      return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
    };
    RegExp_test = RegExp.prototype.test;
    testRegExp = function(re, string) {
      return RegExp_test.call(re, string);
    };
    nonSpaceRe = /\S/;
    isWhitespace = function(string) {
      return !testRegExp(nonSpaceRe, string);
    };
    entityMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '\"': '&quot;',
      '\'': '&#39;',
      '/': '&#x2F;'
    };
    escapeHtml = function(string) {
      return String(string).replace(/[&<>"'\/]/g, function(s) {
        return entityMap[s];
      });
    };
    whiteRe = /\s*/;
    spaceRe = /\s+/;
    equalsRe = /\s*=/;
    curlyRe = /\s*\}/;
    tagRe = /#|\^|\/|>|\{|&|=|!/;
    parseTemplate = function(template, tags) {
      var compileTags, hasTag, nonSpace, openSection, scanner, sections, spaces, start, stripSpace, token, tokens, type, value;
      if (!template) {
        return [];
      }
      sections = [];
      tokens = [];
      spaces = [];
      hasTag = false;
      nonSpace = false;
      stripSpace = function() {
        if (hasTag && !nonSpace) {
          while (spaces.length) {
            delete tokens[spaces.pop()];
          }
        } else {
          spaces = [];
        }
        hasTag = false;
        return nonSpace = false;
      };
      compileTags = function(tags) {
        var closingCurlyRe, closingTagRe, openingTagRe;
        if (typeof tags === 'string') {
          tags = tags.split(spaceRe, 2);
        }
        if (!isArray(tags) || tags.length !== 2) {
          throw new Error('Invalid tags: ' + tags);
        }
        openingTagRe = new RegExp(escapeRegExp(tags[0]) + '\\s*');
        closingTagRe = new RegExp('\\s*' + escapeRegExp(tags[1]));
        return closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tags[1]));
      };
      compileTags(tags || mustache.tags);
      scanner = new Scanner(template);
      while (!!scanner.eos()) {
        start = scanner.pos;
        value = scanner.scanUntil(openingTagRe);

        /*
        value?
          for (i = 0, valueLength = value.length; i < valueLength; ++i)
            chr = value.charAt(i)
        
            if (isWhitespace(chr))
              spaces.push(tokens.length)
            else
              nonSpace = true
        
        
            tokens.push([ 'text', chr, start, start + 1 ])
            start += 1
        
            stripSpace() if (chr is '\n')
         */
        if (!scanner.scan(openingTagRe)) {
          break;
        }
        hasTag = true;
        type = scanner.scan(tagRe) || 'name';
        scanner.scan(whiteRe);
        if (type === '=') {
          value = scanner.scanUntil(equalsRe);
          scanner.scan(equalsRe);
          scanner.scanUntil(closingTagRe);
        } else if (type === '{') {
          value = scanner.scanUntil(closingCurlyRe);
          scanner.scan(curlyRe);
          scanner.scanUntil(closingTagRe);
          type = '&';
        } else {
          value = scanner.scanUntil(closingTagRe);
        }
        if (!scanner.scan(closingTagRe)) {
          throw new Error('Unclosed tag at ' + scanner.pos);
        }
        token = [type, value, start, scanner.pos];
        tokens.push(token);
        if (type === '#' || type === '^') {
          sections.push(token);
        } else if (type === '/') {
          openSection = sections.pop();
          if (!openSection) {
            throw new Error('Unopened section "' + value + '" at ' + start);
          }
          if (openSection[1] !== value) {
            throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
          }
        } else if (type === 'name' || type === '{' || type === '&') {
          nonSpace = true;
        } else if (type === '=') {
          compileTags(value);
        }
      }
      openSection = sections.pop();
      if (openSection) {
        throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
      }
      return nestTokens(squashTokens(tokens));
    };
    squashTokens = function(tokens) {
      var squashedTokens;
      squashedTokens = [];

      /*
      for (var i = 0, numTokens = tokens.length; i < numTokens ++i) {
        token = tokens[i]
      
        token?
          if (token[0] is 'text' and lastToken and lastToken[0] is 'text')
            lastToken[1] += token[1]
            lastToken[3] = token[3]
          else
            squashedTokens.push(token)
            lastToken = token
      }
       */
      return squashedTokens;
    };
    nestTokens = function(tokens) {
      var collector, nestedTokens, sections, token, tokenParse, _i, _len;
      nestedTokens = [];
      collector = nestedTokens;
      sections = [];
      tokenParse = function(token) {
        var section;
        switch (token[0]) {
          case '#':
          case '^':
            collector.push(token);
            sections.push(token);
            return collector = token[4] = [];
          case '/':
            section = sections.pop();
            section[5] = token[2];
            return collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
          default:
            return collector.push(token);
        }
      };
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        tokenParse(token);
      }
      return collector;
    };
    Scanner = function(string) {
      this.string = string;
      this.tail = string;
      return this.pos = 0;
    };
    Scanner.prototype.eos = function() {
      return this.tail === '';
    };
    Scanner.prototype.scan = function(re) {
      var match, string;
      match = this.tail.match(re);
      if (!match || match.index !== 0) {
        return '';
      }
      string = match[0];
      this.tail = this.tail.slice(string.length);
      this.pos += string.length;
      return string;
    };
    Scanner.prototype.scanUntil = function(re) {
      var index, match;
      index = this.tail.search(re);
      switch (index) {
        case -1:
          match = this.tail;
          this.tail = '';
          break;
        case 0:
          match = '';
          break;
        default:
          match = this.tail.slice(0, index);
          this.tail = this.tail.slice(index);
      }
      this.pos += match.length;
      return match;
    };
    Context = function(view, parentContext) {
      this.view = view != null ? view : {};
      this.cache = {
        '.': this.view
      };
      return this.parent = parentContext;
    };
    Context.prototype.push = function(view) {
      return new Context(view, this);
    };
    Context.prototype.lookup = function(name) {
      var cache, value;
      cache = this.cache;
      if ((__indexOf.call(cache, name) >= 0)) {
        value = cache[name];
      } else {

        /*
        context = this, names, index
        
        while (context) {
        
          if (name.indexOf('.') > 0)
            value = context.view
            names = name.split('.')
            index = 0
            value = value[names[index++]] while (value isnt null and index < names.length)
          else
            value = context.view[name]
        
          break if (value isnt null)
        
          context = context.parent
        }
         */
        cache[name] = value;
      }
      if (isFunction(value)) {
        value = value.call(this.view);
      }
      return value;
    };
    Writer = function() {
      return this.cache = {};
    };
    Writer.prototype.clearCache = function() {
      return this.cache = {};
    };
    Writer.prototype.parse = function(template, tags) {
      var cache, tokens;
      cache = this.cache;
      tokens = cache[template];
      if (tokens === null) {
        tokens = cache[template] = parseTemplate(template, tags);
      }
      return tokens;
    };
    Writer.prototype.render = function(template, view, partials) {
      var context, tokens;
      tokens = this.parse(template);
      context = view instanceof Context ? view : new Context(view);
      return this.renderTokens(tokens, context, partials, template);
    };
    Writer.prototype.renderTokens = function(tokens, context, partials, originalTemplate) {
      var buffer, self, subRender;
      buffer = '';
      self = this;
      subRender = function(template) {
        return self.render(template, context, partials);

        /*
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i]
        
          switch token[0]
            when '#'
              value = context.lookup(token[1])
        
              continue if !value
        
              if (isArray(value))
                for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
                    buffer += @renderTokens(token[4], context.push(value[j]), partials, originalTemplate)
                }
              else if (typeof value is 'object' or typeof value is 'string')
                  buffer += @renderTokens(token[4], context.push(value), partials, originalTemplate)
              else if (isFunction(value))
        
                throw new Error('Cannot use higher-order sections without the original template') if (typeof originalTemplate isnt 'string')
        
                value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender)
        
        
                buffer += valueaw if (value isnt null)
        
              else
                buffer += @renderTokens(token[4], context, partials, originalTemplate)
        
            when '^'
              value = context.lookup(token[1])
        
              buffer += @renderTokens(token[4], context, partials, originalTemplate) if (!value or (isArray(value) and value.length is 0))
        
            when '>'
              continue if (!partials)
        
              value = isFunction(partials) ? partials(token[1]) : partials[token[1]]
        
              buffer += @renderTokens(@parse(value), context, partials, value) if (value isnt null)
        
            when '&'
              value = context.lookup(token[1])
              buffer += value if (value isnt null)
        
            when 'name'
              value = context.lookup(token[1])
              buffer += mustache.escape(value) if (value isnt null)
        
            when 'text'
               buffer += token[1]
        }
         */
      };
      return buffer;
    };
    mustache.name = 'mustache.js';
    mustache.version = '0.8.1';
    mustache.tags = ['{{', '}}'];
    defaultWriter = new Writer();
    mustache.clearCache = function() {
      return defaultWriter.clearCache();
    };
    mustache.parse = function(template, tags) {
      return defaultWriter.parse(template, tags);
    };
    mustache.render = function(template, view, partials) {
      return defaultWriter.render(template, view, partials);
    };
    mustache.to_html = function(template, view, partials, send) {
      var result;
      result = mustache.render(template, view, partials);
      if (isFunction(send)) {
        return send(result);
      } else {
        return result;
      }
    };
    mustache.escape = escapeHtml;
    mustache.Scanner = Scanner;
    mustache.Context = Context;
    return mustache.Writer = Writer;
  };

  (function(global, factory) {
    if (typeof exports === 'object' && exports) {
      return factory(exports);
    } else if (typeof define === 'function' && define.amd) {
      return define(['exports'], factory);
    } else {
      return factory(global.Mustache = {});
    }
  })(this, factory);

}).call(this);
