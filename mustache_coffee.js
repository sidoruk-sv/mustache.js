// Generated by CoffeeScript 1.8.0

/*!
 mustache.js - Logic-less {{mustache}} templates with JavaScript
 http://github.com/janl/mustache.js
 */


/*
global define: false
 */

(function() {
  var factory,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  factory = function(mustache) {
    var Context, Object_toString, RegExp_test, Scanner, Writer, curlyRe, defaultWriter, entityMap, equalsRe, escapeHtml, escapeRegExp, isArray, isArrayOld, isFunction, isWhitespace, nestTokens, nonSpaceRe, parseTemplate, spaceRe, squashTokens, tagRe, testRegExp, whiteRe;
    Object_toString = Object.prototype.toString;
    isArrayOld = function(object) {
      return Object_toString.call(object) === '[object Array]';
    };
    isArray = Array.isArray || isArrayOld;
    isFunction = function(object) {
      return typeof object === 'function';
    };
    escapeRegExp = function(string) {
      return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
    };
    RegExp_test = RegExp.prototype.test;
    testRegExp = function(re, string) {
      return RegExp_test.call(re, string);
    };
    nonSpaceRe = /\S/;
    isWhitespace = function(string) {
      return !testRegExp(nonSpaceRe, string);
    };
    entityMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '\"': '&quot;',
      '\'': '&#39;',
      '/': '&#x2F;'
    };
    escapeHtml = function(string) {
      return String(string).replace(/[&<>"'\/]/g, function(s) {
        return entityMap[s];
      });
    };
    whiteRe = /\s*/;
    spaceRe = /\s+/;
    equalsRe = /\s*=/;
    curlyRe = /\s*\}/;
    tagRe = /#|\^|\/|>|\{|&|=|!/;

    /**
       * Breaks up the given `template` string into a tree of tokens. If the `tags`
       * argument is given here it must be an array with two string values: the
       * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
       * course, the default is to use mustaches (i.e. mustache.tags).
       *
       * A token is an array with at least 4 elements. The first element is the
       * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
       * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
       * all text that appears outside a symbol this element is "text".
       *
       * The second element of a token is its "value". For mustache tags this is
       * whatever else was inside the tag besides the opening symbol. For text tokens
       * this is the text itself.
       *
       * The third and fourth elements of the token are the start and end indices,
       * respectively, of the token in the original template.
       *
       * Tokens that are the root node of a subtree contain two more elements: 1) an
       * array of tokens in the subtree and 2) the index in the original template at
       * which the closing tag for that section begins.
     */
    parseTemplate = function(template, tags) {
      var chr, closingCurlyRe, closingTagRe, compileTags, hasTag, i, nonSpace, openSection, openingTagRe, scanner, sections, spaces, start, stripSpace, token, tokens, type, value, _i, _len;
      if (!template) {
        return [];
      }
      sections = [];
      tokens = [];
      spaces = [];
      hasTag = false;
      nonSpace = false;
      stripSpace = function() {
        if (hasTag && !nonSpace) {
          while (spaces.length) {
            delete tokens[spaces.pop()];
          }
        } else {
          spaces = [];
        }
        hasTag = false;
        return nonSpace = false;
      };
      closingCurlyRe = void 0;
      closingTagRe = void 0;
      openingTagRe = void 0;
      compileTags = function(tags) {
        if (typeof tags === 'string') {
          tags = tags.split(spaceRe, 2);
        }
        if (!isArray(tags) || tags.length !== 2) {
          throw new Error("Invalid tags: " + tags);
        }
        openingTagRe = new RegExp("" + (escapeRegExp(tags[0])) + "\\s*");
        closingTagRe = new RegExp("\\s*" + (escapeRegExp(tags[1])));
        return closingCurlyRe = new RegExp("\\s*" + (escapeRegExp('}' + tags[1])));
      };
      compileTags(tags || mustache.tags);
      scanner = new Scanner(template);
      while (!scanner.eos()) {
        start = scanner.pos;
        value = scanner.scanUntil(openingTagRe);
        if (value) {
          for (_i = 0, _len = value.length; _i < _len; _i++) {
            i = value[_i];
            chr = value.charAt(i);
            if (isWhitespace(chr)) {
              spaces.push(tokens.length);
            } else {
              nonSpace = true;
            }
            tokens.push(['text', chr, start, start + 1]);
            start += 1;
            if (chr === '\n') {
              stripSpace();
            }
          }
        }
        if (!scanner.scan(openingTagRe)) {
          break;
        }
        hasTag = true;
        type = scanner.scan(tagRe) || 'name';
        scanner.scan(whiteRe);
        if (type === '=') {
          value = scanner.scanUntil(equalsRe);
          scanner.scan(equalsRe);
          scanner.scanUntil(closingTagRe);
        } else if (type === '{') {
          value = scanner.scanUntil(closingCurlyRe);
          scanner.scan(curlyRe);
          scanner.scanUntil(closingTagRe);
          type = '&';
        } else {
          value = scanner.scanUntil(closingTagRe);
        }
        if (!scanner.scan(closingTagRe)) {
          throw new Error("Unclosed tag at " + scanner.pos);
        }
        token = [type, value, start, scanner.pos];
        tokens.push(token);
        if (type === '#' || type === '^') {
          sections.push(token);
        } else if (type === '/') {
          openSection = sections.pop();
          if (!openSection) {
            throw new Error("Unopened section \"" + value + "\" at " + start);
          }
          if (openSection[1] !== value) {
            throw new Error("Unclosed section \"" + openSection[1] + "\" at " + start);
          }
        } else if (type === 'name' || type === '{' || type === '&') {
          nonSpace = true;
        } else if (type === '=') {
          compileTags(value);
        }
      }
      openSection = sections.pop();
      if (openSection) {
        throw new Error("Unclosed section \"" + openSection[1] + "\" at " + scanner.pos);
      }
      return nestTokens(squashTokens(tokens));
    };

    /**
      * Combines the values of consecutive text tokens in the given `tokens` array
      * to a single token.
     */
    squashTokens = function(tokens) {
      var i, lastToken, squashedTokens, token, _i, _len;
      squashedTokens = [];
      for (i = _i = 0, _len = tokens.length; _i < _len; i = ++_i) {
        token = tokens[i];
        if (!token) {
          continue;
        }
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
      return squashedTokens;
    };

    /**
       * Forms the given array of `tokens` into a nested tree structure where
       * tokens that represent a section have two additional items: 1) an array of
       * all tokens that appear in that section and 2) the index in the original
       * template that represents the end of that section.
     */
    nestTokens = function(tokens) {
      var collector, nestedTokens, sections, token, tokenParse, _i, _len;
      nestedTokens = [];
      collector = nestedTokens;
      sections = [];
      tokenParse = function(token) {
        var section;
        switch (token[0]) {
          case '#':
          case '^':
            collector.push(token);
            sections.push(token);
            return collector = token[4] = [];
          case '/':
            section = sections.pop();
            section[5] = token[2];
            return collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
          default:
            return collector.push(token);
        }
      };
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        tokenParse(token);
      }
      return collector;
    };

    /**
       * A simple string scanner that is used by the template parser to find
       * tokens in template strings.
     */
    Scanner = function(string) {
      this.string = string;
      this.tail = string;
      this.pos = 0;
    };

    /**
       * Returns `true` if the tail is empty (end of string).
     */
    Scanner.prototype.eos = function() {
      return this.tail === '';
    };

    /**
       * Tries to match the given regular expression at the current position.
       * Returns the matched text if it can match, the empty string otherwise.
     */
    Scanner.prototype.scan = function(re) {
      var match, string;
      match = this.tail.match(re);
      if (!match || match.index !== 0) {
        return '';
      }
      string = match[0];
      this.tail = this.tail.slice(string.length);
      this.pos += string.length;
      return string;
    };

    /**
       * Skips all text until the given regular expression can be matched. Returns
       * the skipped string, which is the entire tail if no match can be made.
     */
    Scanner.prototype.scanUntil = function(re) {
      var index, match;
      index = this.tail.search(re);
      switch (index) {
        case -1:
          match = this.tail;
          this.tail = '';
          break;
        case 0:
          match = '';
          break;
        default:
          match = this.tail.slice(0, index);
          this.tail = this.tail.slice(index);
      }
      this.pos += match.length;
      return match;
    };

    /**
       * Represents a rendering context by wrapping a view object and
       * maintaining a reference to the parent context.
     */
    Context = function(view, parentContext) {
      this.view = view != null ? view : {};
      this.cache = {
        '.': this.view
      };
      return this.parent = parentContext;
    };

    /**
       * Creates a new context using the given view with this context
       * as the parent.
     */
    Context.prototype.push = function(view) {
      return new Context(view, this);
    };

    /**
       * Returns the value of the given name in this context, traversing
       * up the context hierarchy if the value is absent in this context's view.
     */
    Context.prototype.lookup = function(name) {
      var cache, context, index, names, value;
      cache = this.cache;
      if (__indexOf.call(cache, name) >= 0) {
        value = cache[name];
      } else {
        context = this;
        names = void 0;
        index = void 0;
        while (context) {
          if (name.indexOf('.') > 0) {
            value = context.view;
            names = name.split('.');
            index = 0;
            while ((value != null) && index < names.length) {
              value = value[names[index++]];
            }
          } else {
            value = context.view[name];
          }
          if (value != null) {
            break;
          }
          context = context.parent;
        }
        cache[name] = value;
      }
      if (isFunction(value)) {
        value = value.call(this.view);
      }
      return value;
    };

    /**
       * A Writer knows how to take a stream of tokens and render them to a
       * string, given a context. It also maintains a cache of templates to
       * avoid the need to parse the same template twice.
     */
    Writer = function() {
      return this.cache = {};
    };

    /**
       * Clears all cached templates in this writer.
     */
    Writer.prototype.clearCache = function() {
      return this.cache = {};
    };

    /**
      * Parses and caches the given `template` and returns the array of tokens
      * that is generated from the parse.
     */
    Writer.prototype.parse = function(template, tags) {
      var cache, tokens;
      cache = this.cache;
      tokens = cache[template];
      if (tokens == null) {
        tokens = cache[template] = parseTemplate(template, tags);
      }
      return tokens;
    };

    /**
       * High-level method that is used to render the given `template` with
       * the given `view`.
       *
       * The optional `partials` argument may be an object that contains the
       * names and templates of partials that are used in the template. It may
       * also be a function that is used to load partial templates on the fly
       * that takes a single argument: the name of the partial.
     */
    Writer.prototype.render = function(template, view, partials) {
      var context, tokens;
      tokens = this.parse(template);
      context = view instanceof Context ? view : new Context(view);
      return this.renderTokens(tokens, context, partials, template);
    };

    /**
       * Low-level method that renders the given array of `tokens` using
       * the given `context` and `partials`.
       *
       * Note: The `originalTemplate` is only ever used to extract the portion
       * of the original template that was contained in a higher-order section.
       * If the template doesn't use higher-order sections, this argument may
       * be omitted.
     */
    Writer.prototype.renderTokens = function(tokens, context, partials, originalTemplate) {
      var buffer, self, subRender;
      buffer = '';
      self = this;
      subRender = function(template) {
        var i, j, k, token, value, _i, _len, _ref, _results;
        self.render(template, context, partials);
        _results = [];
        for (i = _i = 0, _len = tokens.length; _i < _len; i = ++_i) {
          token = tokens[i];
          switch (token[0]) {
            case '#':
              value = context.lookup(token[1]);
              if (!value) {
                continue;
              }
              if (isArray(value)) {
                _results.push((function() {
                  var _j, _len1, _results1;
                  _results1 = [];
                  for (k = _j = 0, _len1 = value.length; _j < _len1; k = ++_j) {
                    j = value[k];
                    _results1.push(buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate));
                  }
                  return _results1;
                }).call(this));
              } else if ((_ref = typeof value) === 'object' || _ref === 'string') {
                _results.push(buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate));
              } else if (isFunction(value)) {
                if (typeof originalTemplate !== 'string') {
                  throw new Error('Cannot use higher-order sections without the original template');
                }
                value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
                if (value != null) {
                  _results.push(buffer += value);
                } else {
                  _results.push(void 0);
                }
              } else {
                _results.push(buffer += this.renderTokens(token[4], context, partials, originalTemplate));
              }
              break;
            case '^':
              value = context.lookup(token[1]);
              if (!value || (isArray(value) && value.length === 0)) {
                _results.push(buffer += this.renderTokens(token[4], context, partials, originalTemplate));
              } else {
                _results.push(void 0);
              }
              break;
            case '>':
              if (!partials) {
                continue;
              }
              value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
              if (value != null) {
                _results.push(buffer += this.renderTokens(this.parse(value), context, partials, value));
              } else {
                _results.push(void 0);
              }
              break;
            case '&':
              value = context.lookup(token[1]);
              if (value != null) {
                _results.push(buffer += value);
              } else {
                _results.push(void 0);
              }
              break;
            case 'name':
              value = context.lookup(token[1]);
              if (value != null) {
                _results.push(buffer += mustache.escape(value));
              } else {
                _results.push(void 0);
              }
              break;
            case 'text':
              _results.push(buffer += token[1]);
              break;
            default:
              _results.push(void 0);
          }
        }
        return _results;
      };
      return buffer;
    };
    mustache.name = 'mustache.js';
    mustache.version = '0.8.1';
    mustache.tags = ['{{', '}}'];
    defaultWriter = new Writer();

    /**
       * Clears all cached templates in the default writer.
     */
    mustache.clearCache = function() {
      return defaultWriter.clearCache();
    };

    /**
       * Parses and caches the given template in the default writer and returns the
       * array of tokens it contains. Doing this ahead of time avoids the need to
       * parse templates on the fly as they are rendered.
     */
    mustache.parse = function(template, tags) {
      return defaultWriter.parse(template, tags);
    };

    /**
       * Renders the `template` with the given `view` and `partials` using the
       * default writer.
     */
    mustache.render = function(template, view, partials) {
      return defaultWriter.render(template, view, partials);
    };
    mustache.to_html = function(template, view, partials, send) {
      var result;
      result = mustache.render(template, view, partials);
      if (isFunction(send)) {
        return send(result);
      } else {
        return result;
      }
    };
    mustache.escape = escapeHtml;
    mustache.Scanner = Scanner;
    mustache.Context = Context;
    return mustache.Writer = Writer;
  };

  (function(global, factory) {
    if (typeof exports === 'object' && exports) {
      return factory(exports);
    } else if (typeof define === 'function' && define.amd) {
      return define(['exports'], factory);
    } else {
      return factory(global.Mustache = {});
    }
  })(this, factory);

}).call(this);
